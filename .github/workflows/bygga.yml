name: Bygga

on:
  workflow_dispatch:
    inputs:
      runs_on:
        description: '指定运行的操作系统环境'
        required: false
        default: 'ubuntu-latest'
      repo_owner:
        description: 'GitHub 用户名或组织名'
        required: true
      repo_name:
        description: '仓库名称'
        required: true
      branch:
        description: '要检出的分支'
        required: true
        default: 'main'
      commands:
        description: '执行命令（用分号 ; 分隔）'
        required: true
        default: 'bun run build'
      output_paths:
        description: '输出路径（用分号 ; 分隔）'
        required: true
        default: 'dist'
      compress_artifacts:
        description: '是否压缩输出'
        required: false
        default: 'false'
      env_vars:
        description: '【加密】环境变量密文（decrypt-env.ts 可识别的密文字符串）'
        required: false
      github_token:
        description: 'Base64 编码的 GitHub Token'
        required: false
        default: ''
      callback_url:
        description: '回调通知地址（可选）'
        required: false
        default: ''

jobs:
  build:
    runs-on: ${{ inputs.runs_on || 'ubuntu-latest' }}

    steps:
    - name: 记录开始时间
      run: |
        START_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        echo "RUN_STARTED_AT=$START_TIME" >> $GITHUB_ENV

    - name: 检出构建工具仓库
      uses: actions/checkout@v4

    - name: 准备 GH_TOKEN
      shell: bash
      run: |
        set -euo pipefail
        raw_b64="${{ inputs.github_token }}"
        if [[ -n "$raw_b64" ]]; then
          cleaned=$(printf '%s' "$raw_b64" | tr -d '\r\n ')
          echo "::add-mask::$cleaned"
          decoded=$(printf '%s' "$cleaned" | base64 -d 2>/dev/null || true)
          if [[ -n "$decoded" ]]; then
            echo "::add-mask::$decoded"
            printf 'GH_TOKEN=%s\n' "$decoded" >> "$GITHUB_ENV"
            unset decoded
          fi
          unset cleaned raw_b64
        fi

    - name: 克隆目标项目
      shell: bash
      env:
        REPO_OWNER: ${{ github.event.inputs.repo_owner }}
        REPO_NAME: ${{ github.event.inputs.repo_name }}
        BRANCH: ${{ github.event.inputs.branch }}
      run: |
        if [ -n "${GH_TOKEN}" ]; then
          echo "::add-mask::${GH_TOKEN}"
        fi
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"

        REPO_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}.git"
        if [ -n "${GH_TOKEN}" ]; then
          REPO_WITH_AUTH=$(echo "$REPO_URL" | sed -E "s#https://#https://${GH_TOKEN}@#")
          git clone -q "$REPO_WITH_AUTH" target-project
          unset REPO_WITH_AUTH
        else
          git clone -q "$REPO_URL" target-project
        fi

        cd target-project
        git checkout "${BRANCH}"

    - name: 安装 Bun
      uses: oven-sh/setup-bun@v1
      with:
        bun-version: latest

    - name: 显示 Bun 版本
      run: bun --version

    - name: 安装工作流依赖
      run: |
        bun add crypto-js child_process

    - name: 安装依赖
      working-directory: target-project
      run: |
        bun install

    - name: 解密并设置环境变量（隐藏写入）
      if: ${{ github.event.inputs.env_vars != '' }}
      working-directory: target-project
      shell: bash
      env:
        ENCRYPTED_ENV: ${{ github.event.inputs.env_vars }}
      run: |
        set -e
        ENV_FILE=".env"
        TEMP_ENV_FILE=$(mktemp)

        bun "$GITHUB_WORKSPACE/.github/workflows/decrypt-env.ts" "${ENCRYPTED_ENV}" "${GH_TOKEN}" "$TEMP_ENV_FILE"

        # 将 .env 内容逐行写入 GITHUB_ENV，并为每个 VALUE 做 add-mask
        while IFS= read -r line || [[ -n "$line" ]]; do
          [[ -z "$line" ]] && continue
          [[ "$line" =~ ^# ]] && continue
          if [[ "$line" == *=* ]]; then
            key="${line%%=*}"
            val="${line#*=}"
            # 去掉可能的包裹引号（不影响 .env 文件，仅用于掩码一致性）
            val_stripped="${val%\"}"
            val_stripped="${val_stripped#\"}"
            val_stripped="${val_stripped%\'}"
            val_stripped="${val_stripped#\'}"
            [[ -n "$val_stripped" ]] && echo "::add-mask::$val_stripped"
            printf '%s=%s\n' "$key" "$val" >> "$GITHUB_ENV"
          fi
        done < "$TEMP_ENV_FILE"

        # 写入项目 .env（不打印内容）
        cp "$TEMP_ENV_FILE" "$ENV_FILE"
        rm -f "$TEMP_ENV_FILE"

    - name: 执行命令（分号分隔）
      working-directory: target-project
      shell: bash
      run: |
        set -e
        CURRENT_DIR=$(pwd)
        CMDS_STR=$(printf '%s' "${{ github.event.inputs.commands }}" | tr -d '\r')
        IFS=';' read -ra COMMANDS <<< "$CMDS_STR"
        for cmd in "${COMMANDS[@]}"; do
          cmd="$(echo "$cmd" | xargs)"
          [ -z "$cmd" ] && continue
          cd "$CURRENT_DIR" && bun "$GITHUB_WORKSPACE/.github/workflows/run_interactive_command.ts" "$cmd" "$CURRENT_DIR"
        done

    - name: 处理输出（分号分隔）
      working-directory: target-project
      shell: bash
      run: |
        set -e
        sudo apt-get update && sudo apt-get install -y zip

        PATHS_STR=$(printf '%s' "${{ github.event.inputs.output_paths }}" | tr -d '\r')
        IFS=';' read -ra PATHS <<< "$PATHS_STR"

        ARTIFACTS_LIST=""
        CLEANED_LINES=""
        for item in "${PATHS[@]}"; do
          item="$(echo "$item" | xargs)"
          [ -z "$item" ] && continue
          if [ -z "$ARTIFACTS_LIST" ]; then
            ARTIFACTS_LIST="$item"
          else
            ARTIFACTS_LIST="$ARTIFACTS_LIST $item"
          fi
          CLEANED_LINES="${CLEANED_LINES}${item}"
        done

        TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
        ZIP_FILE="build-$TIMESTAMP.zip"

        if [[ "${{ github.event.inputs.compress_artifacts }}" == "true" ]]; then
          zip -r "$ZIP_FILE" $ARTIFACTS_LIST
          echo "ARTIFACT_PATH=$ZIP_FILE" >> $GITHUB_ENV
          echo "ARTIFACT_NAME=build-$TIMESTAMP" >> $GITHUB_ENV
        else
          echo "ARTIFACT_NAME=build-$TIMESTAMP" >> $GITHUB_ENV
          {
            echo "ARTIFACT_PATHS<<EOF"
            printf '%s' "$CLEANED_LINES"
            echo "EOF"
          } >> $GITHUB_ENV
        fi

    - name: 上传压缩输出
      uses: actions/upload-artifact@v4
      if: ${{ github.event.inputs.compress_artifacts == 'true' }}
      with:
        name: ${{ env.ARTIFACT_NAME }}
        path: target-project/${{ env.ARTIFACT_PATH }}
        if-no-files-found: error

    - name: 上传未压缩输出
      uses: actions/upload-artifact@v4
      if: ${{ github.event.inputs.compress_artifacts != 'true' }}
      with:
        name: ${{ env.ARTIFACT_NAME }}
        path: |
          ${{ env.ARTIFACT_PATHS }}
        path-pattern: "target-project/{0}"
        if-no-files-found: error

    - name: 结束通知
      run: |
        echo "Artifacts 已生成"

    - name: 回调通知
      if: ${{ always() && inputs.callback_url != '' }}
      shell: bash
      env:
        CALLBACK_URL: ${{ inputs.callback_url }}
        JOB_STATUS: ${{ job.status }}
      run: |
        FINISH_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        start_ts=$(date -u -d "${RUN_STARTED_AT}" +%s 2>/dev/null || echo 0)
        end_ts=$(date -u -d "${FINISH_TIME}" +%s)
        if [ "$start_ts" -gt 0 ]; then DURATION_SEC=$(( end_ts - start_ts )); else DURATION_SEC=0; fi

        payload=$(
          jq -n \
            --arg workflow "${{ github.workflow }}" \
            --arg job "build" \
            --arg status "${JOB_STATUS}" \
            --arg repo_owner "${{ github.event.inputs.repo_owner }}" \
            --arg repo_name "${{ github.event.inputs.repo_name }}" \
            --arg branch "${{ github.event.inputs.branch }}" \
            --arg run_id "${{ github.run_id }}" \
            --arg run_number "${{ github.run_number }}" \
            --arg run_attempt "${{ github.run_attempt }}" \
            --arg artifact_name "${ARTIFACT_NAME:-}" \
            --arg artifact_path "${ARTIFACT_PATH:-}" \
            --arg output_paths_input "${{ github.event.inputs.output_paths }}" \
            --arg compress "${{ github.event.inputs.compress_artifacts }}" \
            --arg started_at "${RUN_STARTED_AT:-}" \
            --arg finished_at "${FINISH_TIME}" \
            --arg duration_sec "${DURATION_SEC}" \
            '{
              workflow: $workflow,
              job: $job,
              status: $status,
              repository: { owner: $repo_owner, name: $repo_name, branch: $branch },
              run: { id: $run_id, number: $run_number, attempt: $run_attempt },
              artifacts: {
                name: $artifact_name,
                compressed_path: ($artifact_path // null),
                output_paths_input: $output_paths_input,
                compress_artifacts: $compress
              },
              timing: { started_at: $started_at, finished_at: $finished_at, duration_sec: ($duration_sec|tonumber) }
            }'
        )

        curl -sS -o /tmp/callback_resp.txt -w "%{http_code}" \
          -H "Content-Type: application/json" \
          -X POST "${CALLBACK_URL}" \
          --data "$payload" >/tmp/callback_code.txt

        http_code=$(cat /tmp/callback_code.txt || echo 0)
        echo "回调响应码: $http_code"
        cat /tmp/callback_resp.txt || true
