name: Bygga

on:
  workflow_dispatch:
    inputs:
      runs_on:
        description: '指定运行的操作系统环境'
        required: false
        default: 'ubuntu-latest'
      repo_owner:
        description: 'GitHub 用户名或组织名'
        required: true
      repo_name:
        description: '仓库名称'
        required: true
      branch:
        description: '要检出的分支'
        required: true
        default: 'main'
      commands:
        description: '执行命令（用分号 ; 分隔）'
        required: true
        default: 'bun run build'
      output_paths:
        description: '输出路径（用分号 ; 分隔）'
        required: true
        default: 'dist'
      compress_artifacts:
        description: '是否压缩输出'
        required: false
        default: 'false'
      env_vars:
        description: '【加密】环境变量密文（decrypt-env.ts 可识别的密文字符串）'
        required: false
      github_token:
        description: 'Base64 编码的 GitHub Token'
        required: false
        default: ''
      callback_url:
        description: '回调通知地址（已自带 task_id 查询参数）'
        required: false
        default: ''

jobs:
  build:
    runs-on: ${{ inputs.runs_on || 'ubuntu-latest' }}

    steps:
    - name: 记录开始时间
      run: |
        START_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        echo "RUN_STARTED_AT=$START_TIME" >> $GITHUB_ENV

    - name: 安装工具（jq/zip）
      shell: bash
      run: |
        sudo apt-get -qq update
        sudo apt-get -qq install -y jq zip >/dev/null

    - name: 检出构建工具仓库
      uses: actions/checkout@v4

    - name: 准备 GH_TOKEN
      shell: bash
      run: |
        set -euo pipefail
        raw_b64="${{ inputs.github_token }}"
        if [[ -n "$raw_b64" ]]; then
          cleaned=$(printf '%s' "$raw_b64" | tr -d '\r\n ')
          echo "::add-mask::$cleaned"
          decoded=$(printf '%s' "$cleaned" | base64 -d 2>/dev/null || true)
          if [[ -n "$decoded" ]]; then
            echo "::add-mask::$decoded"
            printf 'GH_TOKEN=%s\n' "$decoded" >> "$GITHUB_ENV"
            unset decoded
          fi
          unset cleaned raw_b64
        fi

    - name: 回调（开始：running）
      if: ${{ inputs.callback_url != '' }}
      shell: bash
      run: |
        set -euo pipefail
        raw_url="${{ inputs.callback_url }}"
        url="$(printf '%s' "$raw_url" | tr -d '\r')"
        echo "::add-mask::$url"
        payload='{"status":"running"}'
        http_code=$(
          curl -sS -o /tmp/callback_resp_start.txt -w "%{http_code}" \
            -H "Content-Type: application/json" \
            -X POST "$url" \
            --data "$payload"
        ) || http_code=0
        if [ "${http_code}" -lt 200 ] || [ "${http_code}" -ge 300 ]; then
          echo "::warning::开始回调返回非 2xx 状态码: ${http_code}"
        fi
        rm -f /tmp/callback_resp_start.txt || true

    - name: 克隆目标项目
      shell: bash
      env:
        REPO_OWNER: ${{ github.event.inputs.repo_owner }}
        REPO_NAME: ${{ github.event.inputs.repo_name }}
        BRANCH: ${{ github.event.inputs.branch }}
      run: |
        if [ -n "${GH_TOKEN:-}" ]; then
          echo "::add-mask::${GH_TOKEN}"
        fi
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"

        REPO_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}.git"
        if [ -n "${GH_TOKEN:-}" ]; then
          REPO_WITH_AUTH=$(echo "$REPO_URL" | sed -E "s#https://#https://${GH_TOKEN}@#")
          git clone -q "$REPO_WITH_AUTH" target-project
          unset REPO_WITH_AUTH
        else
          git clone -q "$REPO_URL" target-project
        fi

        cd target-project
        git checkout "${BRANCH}"

    - name: 安装 Bun
      uses: oven-sh/setup-bun@v1
      with:
        bun-version: latest

    - name: 显示 Bun 版本
      run: bun --version

    - name: 安装工作流依赖
      run: |
        bun add crypto-js child_process

    - name: 安装依赖
      working-directory: target-project
      run: |
        bun install

    - name: 解密并设置环境变量（隐藏写入）
      if: ${{ github.event.inputs.env_vars != '' }}
      working-directory: target-project
      shell: bash
      env:
        ENCRYPTED_ENV: ${{ github.event.inputs.env_vars }}
      run: |
        set -euo pipefail
        ENV_FILE=".env"
        TEMP_ENV_FILE=$(mktemp)

        bun "$GITHUB_WORKSPACE/.github/workflows/decrypt-env.ts" "${ENCRYPTED_ENV}" "${GH_TOKEN:-}" "$TEMP_ENV_FILE"

        while IFS= read -r line || [[ -n "$line" ]]; do
          [[ -z "$line" ]] && continue
          [[ "$line" =~ ^# ]] && continue
          if [[ "$line" == *=* ]]; then
            key="${line%%=*}"
            val="${line#*=}"
            val_stripped="${val%\"}"; val_stripped="${val_stripped#\"}"
            val_stripped="${val_stripped%\'}"; val_stripped="${val_stripped#\'}"
            [[ -n "$val_stripped" ]] && echo "::add-mask::$val_stripped"
            printf '%s=%s\n' "$key" "$val" >> "$GITHUB_ENV"
          fi
        done < "$TEMP_ENV_FILE"

        cp "$TEMP_ENV_FILE" "$ENV_FILE"
        rm -f "$TEMP_ENV_FILE"

    - name: 执行命令（分号分隔）
      working-directory: target-project
      shell: bash
      run: |
        set -euo pipefail
        CURRENT_DIR=$(pwd)
        CMDS_STR=$(printf '%s' "${{ github.event.inputs.commands }}" | tr -d '\r')
        IFS=';' read -ra COMMANDS <<< "$CMDS_STR"
        for cmd in "${COMMANDS[@]}"; do
          cmd="$(echo "$cmd" | xargs)"
          [ -z "$cmd" ] && continue
          cd "$CURRENT_DIR" && bun "$GITHUB_WORKSPACE/.github/workflows/run_interactive_command.ts" "$cmd" "$CURRENT_DIR"
        done

    - name: 处理输出（分号分隔）
      working-directory: target-project
      shell: bash
      run: |
        set -euo pipefail
        PATHS_STR=$(printf '%s' "${{ github.event.inputs.output_paths }}" | tr -d '\r')
        IFS=';' read -ra PATHS <<< "$PATHS_STR"

        ARTIFACTS_LIST=""
        CLEANED_LINES=""
        for item in "${PATHS[@]}"; do
          item="$(echo "$item" | xargs)"
          [ -z "$item" ] && continue
          if [ -z "$ARTIFACTS_LIST" ]; then
            ARTIFACTS_LIST="$item"
          else
            ARTIFACTS_LIST="$ARTIFACTS_LIST $item"
          fi
          CLEANED_LINES="${CLEANED_LINES}${item}"
        done

        TIMESTAMP=$(date +"%Y%m%d-%H%M%S")
        ZIP_FILE="build-$TIMESTAMP.zip"

        if [[ "${{ github.event.inputs.compress_artifacts }}" == "true" ]]; then
          zip -r "$ZIP_FILE" $ARTIFACTS_LIST >/dev/null
          echo "ARTIFACT_PATH=$ZIP_FILE" >> $GITHUB_ENV
          echo "ARTIFACT_NAME=build-$TIMESTAMP" >> $GITHUB_ENV
        else
          echo "ARTIFACT_NAME=build-$TIMESTAMP" >> $GITHUB_ENV
          {
            echo "ARTIFACT_PATHS<<EOF"
            printf '%s' "$CLEANED_LINES"
            echo "EOF"
          } >> $GITHUB_ENV
        fi

    - name: 上传压缩输出
      uses: actions/upload-artifact@v4
      if: ${{ github.event.inputs.compress_artifacts == 'true' }}
      with:
        name: ${{ env.ARTIFACT_NAME }}
        path: target-project/${{ env.ARTIFACT_PATH }}
        if-no-files-found: error

    - name: 上传未压缩输出
      uses: actions/upload-artifact@v4
      if: ${{ github.event.inputs.compress_artifacts != 'true' }}
      with:
        name: ${{ env.ARTIFACT_NAME }}
        path: |
          ${{ env.ARTIFACT_PATHS }}
        path-pattern: "target-project/{0}"
        if-no-files-found: error

    - name: 回调（结束：success/failed/cancelled）
      if: ${{ always() && inputs.callback_url != '' }}
      shell: bash
      run: |
        set -euo pipefail
        case "${{ job.status }}" in
          success)   STATUS="success" ;;
          failure)   STATUS="failed" ;;
          cancelled) STATUS="cancelled" ;;
          *)         STATUS="failed" ;;
        esac

        raw_url="${{ inputs.callback_url }}"
        url="$(printf '%s' "$raw_url" | tr -d '\r')"
        echo "::add-mask::$url"

        GITHUB_RUN_URL="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
        ARTIFACTS_URL="${GITHUB_RUN_URL}#artifacts"

        payload=$(
          jq -n \
            --arg status "$STATUS" \
            --arg run_url "$GITHUB_RUN_URL" \
            --arg artifacts_url "$ARTIFACTS_URL" \
            '{status: $status, github_run_url: $run_url, artifacts_url: $artifacts_url}'
        )

        http_code=$(
          curl -sS -o /tmp/callback_resp_end.txt -w "%{http_code}" \
            -H "Content-Type: application/json" \
            -X POST "$url" \
            --data "$payload"
        ) || http_code=0

        if [ "${http_code}" -lt 200 ] || [ "${http_code}" -ge 300 ]; then
          echo "::warning::结束回调返回非 2xx 状态码: ${http_code}"
        fi
        rm -f /tmp/callback_resp_end.txt || true
