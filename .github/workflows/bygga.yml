name: Bygga

on:
  workflow_dispatch:
    inputs:
      runs_on:
        required: false
        default: 'ubuntu-latest'
      repo_owner:
        required: true
      repo_name:
        required: true
      branch:
        required: true
        default: 'main'
      commands:
        required: true
        default: 'bun run build'
      output_paths:
        required: true
        default: 'dist'
      env_vars:
        required: false
      github_token:
        required: false
        default: ''
      callback_url:
        required: false
        default: ''

permissions:
  contents: read
  actions: read

jobs:
  build:
    runs-on: ${{ inputs.runs_on || 'ubuntu-latest' }}

    steps:
    - name: 记录开始时间
      run: |
        echo "RUN_STARTED_AT=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_ENV

    - name: 安装工具
      shell: bash
      run: |
        sudo apt-get -qq update
        sudo apt-get -qq install -y jq zip >/dev/null
        set -euo pipefail
        RAW="${{ inputs.github_token }}"
        if [[ -n "$RAW" ]]; then
          CLEAN=$(printf '%s' "$RAW" | tr -d '\r\n ')
          echo "::add-mask::$CLEAN"
          DEC=$(printf '%s' "$CLEAN" | base64 -d 2>/dev/null || true)
          if [[ -n "$DEC" ]]; then
            echo "::add-mask::$DEC"
            printf 'GH_TOKEN=%s\n' "$DEC" >> "$GITHUB_ENV"
          fi
        fi

    - name: 检出工作流仓库
      uses: actions/checkout@v4

    - name: 安装 Bun
      uses: oven-sh/setup-bun@v1
      with:
        bun-version: latest

    - name: 显示 Bun 版本
      run: bun --version

    - name: 安装 Rust
      uses: dtolnay/rust-toolchain@stable
      
    - name: 安装工作流依赖
      run: bun add crypto-js child_process

    - name: 回调（开始 running）
      if: ${{ inputs.callback_url != '' }}
      shell: bash
      run: |
        URL="${{ inputs.callback_url }}"
        URL="$(printf '%s' "$URL" | tr -d '\r')"
        echo "::add-mask::$URL"
        curl -sS -o /tmp/cb_start.txt -w "%{http_code}" \
          -H "Content-Type: application/json" \
          -X POST "$URL" \
          --data '{"status":"running"}' || true
        rm -f /tmp/cb_start.txt || true

    - name: 克隆目标项目
      shell: bash
      run: |
        set -euo pipefail
        REPO_OWNER='${{ inputs.repo_owner }}'
        REPO_NAME='${{ inputs.repo_name }}'
        BRANCH='${{ inputs.branch }}'

        if [ -n "${GH_TOKEN:-}" ]; then echo "::add-mask::${GH_TOKEN}"; fi
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"

        REPO_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}.git"
        if [ -n "${GH_TOKEN:-}" ]; then
          AUTH_URL=$(echo "$REPO_URL" | sed -E "s#https://#https://${GH_TOKEN}@#")
          git clone -q "$AUTH_URL" target-project
          unset AUTH_URL
        else
          git clone -q "$REPO_URL"
          mv "${REPO_NAME}" target-project
        fi
        cd target-project
        git checkout "${BRANCH}"
        
    - name: 安装依赖
      working-directory: target-project
      run: bun install

    - name: 解密并设置环境变量（隐藏写入）
      if: ${{ inputs.env_vars != '' }}
      working-directory: target-project
      shell: bash
      env:
        ENCRYPTED_ENV: ${{ inputs.env_vars }}
      run: |
        set -euo pipefail
        ENV_FILE=".env"
        TMP=$(mktemp)
        bun "$GITHUB_WORKSPACE/.github/workflows/decrypt-env.ts" "${ENCRYPTED_ENV}" "${GH_TOKEN:-}" "$TMP"
        while IFS= read -r line || [[ -n "$line" ]]; do
          [[ -z "$line" || "$line" =~ ^# ]] && continue
          if [[ "$line" == *=* ]]; then
            k="${line%%=*}"; v="${line#*=}"
            scrub="${v%\"}"; scrub="${scrub#\"}"; scrub="${scrub%\'}"; scrub="${scrub#\'}"
            [[ -n "$scrub" ]] && echo "::add-mask::$scrub"
            printf '%s=%s\n' "$k" "$v" >> "$GITHUB_ENV"
          fi
        done < "$TMP"
        cp "$TMP" "$ENV_FILE"
        rm -f "$TMP"

    - name: 执行命令（; 分隔）
      working-directory: target-project
      shell: bash
      run: |
        set -euo pipefail
        BASE=$(pwd)
        CMDS=$(printf '%s' "${{ inputs.commands }}" | tr -d '\r')
        IFS=';' read -ra ARR <<< "$CMDS"
        for cmd in "${ARR[@]}"; do
          cmd="$(echo "$cmd" | xargs)"; [ -z "$cmd" ] && continue
          cd "$BASE" && bun "$GITHUB_WORKSPACE/.github/workflows/run_interactive_command.ts" "$cmd" "$BASE"
        done

    - name: 汇总输出 → 单一 ZIP
      working-directory: target-project
      shell: bash
      run: |
        set -euo pipefail
        TS=$(date +"%Y%m%d-%H%M%S")
        ZIP_NAME="build-$TS"
        ZIP_FILE="$ZIP_NAME.zip"

        RAW=$(printf '%s' "${{ inputs.output_paths }}" | tr -d '\r')
        IFS=';' read -ra PATHS <<< "$RAW"
        readarray -t PTHS < <(for p in "${PATHS[@]}"; do echo "$p" | xargs; done | sed '/^$/d')
        if [ "${#PTHS[@]}" -eq 0 ]; then
          echo "未提供有效输出路径" >&2
          exit 1
        fi

        for p in "${PTHS[@]}"; do
          if [ -d "$p" ]; then
            (cd "$(dirname "$p")" && zip -r "$OLDPWD/$ZIP_FILE" "$(basename "$p")" >/dev/null)
          elif [ -f "$p" ]; then
            zip -j "$ZIP_FILE" "$p" >/dev/null 2>/dev/null || zip "$ZIP_FILE" "$p" >/dev/null
          fi
        done

        if command -v stat >/dev/null 2>&1; then
          SIZE=$(stat -c%s "$ZIP_FILE" 2>/dev/null || stat -f%z "$ZIP_FILE" 2>/dev/null || wc -c <"$ZIP_FILE")
        else
          SIZE=$(wc -c <"$ZIP_FILE")
        fi
        echo "ARTIFACT_NAME=$ZIP_NAME" >> $GITHUB_ENV
        echo "ARTIFACT_PATH=$ZIP_FILE" >> $GITHUB_ENV
        echo "ARTIFACT_SIZE=$SIZE" >> $GITHUB_ENV

    - name: 上传产物（单一 ZIP）
      id: upload_art
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.ARTIFACT_NAME }}
        path: target-project/${{ env.ARTIFACT_PATH }}
        if-no-files-found: error

    - name: 回调（结束）
      if: ${{ always() && inputs.callback_url != '' }}
      shell: bash
      env:
        OWNER: ${{ github.repository_owner }}
        REPO: ${{ github.event.repository.name }}
        RUN_ID: ${{ github.run_id }}
      run: |
        set -euo pipefail

        case "${{ job.status }}" in
          success) STATUS="success" ;;
          failure) STATUS="failed" ;;
          cancelled) STATUS="cancelled" ;;
          *) STATUS="failed" ;;
        esac

        RUN_URL="https://github.com/${OWNER}/${REPO}/actions/runs/${RUN_ID}"

        ART_ID="${{ steps.upload_art.outputs.artifact-id }}"
        ART_URL="${{ steps.upload_art.outputs.artifact-url }}"
        NAME="${{ env.ARTIFACT_NAME }}"
        SIZE="${{ env.ARTIFACT_SIZE }}"

        # archive_url：使用 v4 输出的 artifact-url（原始 URL）
        ARCHIVE_URL="${ART_URL:-}"

        # download_url：用规则拼接 UI 地址
        DOWNLOAD_URL=""
        if [ -n "$ART_ID" ]; then
          DOWNLOAD_URL="https://github.com/${OWNER}/${REPO}/actions/runs/${RUN_ID}/artifacts/${ART_ID}"
        fi

        artifacts=$(jq -n \
          --arg id "${ART_ID:-0}" \
          --arg name "$NAME" \
          --arg size "${SIZE:-0}" \
          --arg arch "${ARCHIVE_URL:-}" \
          --arg down "${DOWNLOAD_URL:-}" \
          '[{
            id: ($id|tonumber),
            name: $name,
            size_in_bytes: ($size|tonumber),
            archive_url: $arch,
            download_url: $down
          }]')

        CB="${{ inputs.callback_url }}"
        CB="$(printf '%s' "$CB" | tr -d '\r')"
        echo "::add-mask::$CB"

        payload=$(jq -n \
          --arg status "$STATUS" \
          --arg run_url "$RUN_URL" \
          --argjson artifacts "$artifacts" \
          '{status: $status, github_run_url: $run_url, artifacts: $artifacts}')

        curl -sS -o /tmp/callback_resp_end.txt -w "%{http_code}" \
          -H "Content-Type: application/json" \
          -X POST "$CB" \
          --data "$payload" || true
        rm -f /tmp/callback_resp_end.txt || true
